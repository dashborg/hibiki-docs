[{"id":0,"href":"/reference/actions/","title":"Actions","parent":"Reference","content":"Hibiki HTML handlers run actions to manipulate the page state. Actions can be run by frontend Hibiki HTML code, or they can be returned as JSON from backend code.\nTo return actions as JSON return an object with a key named \u0026ldquo;hibikiactions\u0026rdquo;:\n{ \u0026quot;hibikiactions\u0026quot;: [action-json, action-json, ...], }       setdata setreturn callhandler fireevent throw ifblock html log nop       setdata    The setdata action updates data in the data model:\n actiontype - \u0026ldquo;setdata\u0026rdquo; setpath - the path to set data - literal value to set setop (optional) - the setop to run, defaults to \u0026ldquo;set\u0026rdquo;  Here are some example setdata actions:\n{\u0026quot;actiontype\u0026quot;: \u0026quot;setdata\u0026quot;, \u0026quot;setpath\u0026quot;: \u0026quot;$.color\u0026quot;, \u0026quot;data\u0026quot;: \u0026quot;blue\u0026quot;} {\u0026quot;actiontype\u0026quot;: \u0026quot;setdata\u0026quot;, \u0026quot;setpath\u0026quot;: \u0026quot;$.customers[5].first_name\u0026quot;, \u0026quot;data\u0026quot;: \u0026quot;mike\u0026quot;} {\u0026quot;actiontype\u0026quot;: \u0026quot;setdata\u0026quot;, \u0026quot;setpath\u0026quot;: \u0026quot;$.points\u0026quot;, \u0026quot;data\u0026quot;: [[0,5], [2,8], [-1, 4]]} {\u0026quot;actiontype\u0026quot;: \u0026quot;setdata\u0026quot;, \u0026quot;setpath\u0026quot;: \u0026quot;$.points\u0026quot;, \u0026quot;setop\u0026quot;: \u0026quot;append\u0026quot;, \u0026quot;data\u0026quot;: [8, 12]} {\u0026quot;actiontype\u0026quot;: \u0026quot;setdata\u0026quot;, \u0026quot;setpath\u0026quot;: \u0026quot;$c.points\u0026quot;, \u0026quot;data\u0026quot;: 80} setreturn    The setreturn action sets the handler\u0026rsquo;s return value. It is up to the frontend code to assign or discard the return value. Note that if you return a JSON body that does not have the \u0026ldquo;hibikiactions\u0026rdquo; key, it gets implicitly turned into a \u0026ldquo;setreturn\u0026rdquo; value.\n actiontype - \u0026ldquo;setreturn\u0026rdquo; data - literal value to return  {\u0026quot;actiontype\u0026quot;: \u0026quot;setreturn\u0026quot;, \u0026quot;data\u0026quot;: 8} {\u0026quot;actiontype\u0026quot;: \u0026quot;setreturn\u0026quot;, \u0026quot;data\u0026quot;: {\u0026quot;first_name\u0026quot;: \u0026quot;Mike\u0026quot;, company: \u0026quot;Dashborg\u0026quot;, \u0026quot;status\u0026quot;: \u0026quot;active\u0026quot;}} callhandler    The callhandler action calls another handler. Use setpath to capture the return value.\n actiontype - \u0026ldquo;callhandler\u0026rdquo; callpath - the handler path (string) data - data to pass to the handler, must be null or an object (cannot be array or scalar value) pure (optional) - set to true to run as a pure handler (no side effects, only provides a return value)  {\u0026quot;actiontype\u0026quot;: \u0026quot;callhandler\u0026quot;, \u0026quot;callpath\u0026quot;: \u0026quot;/handler2\u0026quot;, \u0026quot;data\u0026quot;: {\u0026quot;x\u0026quot;: 5}} {\u0026quot;actiontype\u0026quot;: \u0026quot;callhandler\u0026quot;, \u0026quot;callpath\u0026quot;: \u0026quot;/@local/render-d3\u0026quot;, \u0026quot;data\u0026quot;: {\u0026quot;points\u0026quot;: [5, 8, 22, 58]}, \u0026quot;pure\u0026quot;: true} {\u0026quot;actiontype\u0026quot;: \u0026quot;callhandler\u0026quot;, \u0026quot;callpath\u0026quot;: \u0026quot;/@app/get-image\u0026quot;, \u0026quot;setpath\u0026quot;: \u0026quot;$.img\u0026quot;} fireevent    The fireevent action will fire or bubble an event at the point where this handler is running.\n actiontype - \u0026ldquo;fireevent\u0026rdquo; event - the event name (string) bubble (optional) - set to true if this event should bubble data - data associated to the event (becomes context vars, e.g. @val, or @data)  {\u0026quot;actiontype\u0026quot;: \u0026quot;fireevent\u0026quot;, \u0026quot;event\u0026quot;: \u0026quot;custom1\u0026quot;, \u0026quot;data\u0026quot;: {\u0026quot;value\u0026quot;: 22}} {\u0026quot;actiontype\u0026quot;: \u0026quot;fireevent\u0026quot;, \u0026quot;event\u0026quot;: \u0026quot;click\u0026quot;, \u0026quot;bubble\u0026quot;: true} {\u0026quot;actiontype\u0026quot;: \u0026quot;fireevent\u0026quot;, \u0026quot;event\u0026quot;: \u0026quot;submit\u0026quot;, \u0026quot;data\u0026quot;: {\u0026quot;first_name\u0026quot;: \u0026quot;Mike\u0026quot;, value: 42}} throw    The throw action will throw an error (the rest of your actions will not be run). Similar to firing an \u0026ldquo;error\u0026rdquo; event, with bubble set.\n actiontype - \u0026ldquo;throw\u0026rdquo; data - error message (string)  {\u0026quot;actiontype\u0026quot;: \u0026quot;throw\u0026quot;, \u0026quot;data\u0026quot;: \u0026quot;Validation Error, no Customer ID set\u0026quot;} {\u0026quot;actiontype\u0026quot;: \u0026quot;throw\u0026quot;, \u0026quot;data\u0026quot;: \u0026quot;Internal Error\u0026quot;} {\u0026quot;actiontype\u0026quot;: \u0026quot;throw\u0026quot;, \u0026quot;data\u0026quot;: \u0026quot;DB Error, cannot connect to database\u0026quot;} ifblock    The ifblock action will create a dynamic if/then/else statement. First data is evaluated. If true, the actions[\u0026ldquo;then\u0026rdquo;] will be run. If false actions[\u0026ldquo;else\u0026rdquo;] will be run. Either actions block can be empty.\nNormally for backend code, this action only makes sense when combined with hibikiexpr (see Actions - Advanced)\n{\u0026quot;actiontype\u0026quot;: \u0026quot;ifblock\u0026quot;, \u0026quot;data\u0026quot;: true, \u0026quot;actions\u0026quot;: {\u0026quot;then\u0026quot;: [... actions ...], \u0026quot;else\u0026quot;: [... actions ...]}} {\u0026quot;actiontype\u0026quot;: \u0026quot;ifblock\u0026quot;, \u0026quot;data\u0026quot;: {\u0026quot;hibikiexpr\u0026quot;: \u0026quot;$.loadcount \u0026gt; 5\u0026quot;}, \u0026quot;actions\u0026quot;: {\u0026quot;then\u0026quot;: [... actions ...]}} html    The html action will overwrite the current Hibiki HTML, and replace it with the given HTML (used to dynamically change pages). Note that configuration data, and frontend data model will be retained.\n actiontype - \u0026ldquo;html\u0026rdquo; html - the HTML to render  {\u0026quot;actiontype\u0026quot;: \u0026quot;html\u0026quot;, \u0026quot;html\u0026quot;: \u0026quot;\u0026lt;h1\u0026gt;header\u0026lt;/h1\u0026gt;...\u0026quot;} {\u0026quot;actiontype\u0026quot;: \u0026quot;html\u0026quot;, \u0026quot;html\u0026quot;: \u0026quot;\u0026lt;p\u0026gt;some text to render\u0026lt;/p\u0026gt;\u0026quot;} log    The log action is for debugging. It will log a value to the console, with optional debugging stack information. It can also fire a browser alert.\n actiontype - \u0026ldquo;log\u0026rdquo; data - the data to log. debug (optional) - if set to true, will log additional debug stack information alert (optional) - if set to true, it will fire a browser alert  {\u0026quot;actiontype\u0026quot;: \u0026quot;log\u0026quot;, \u0026quot;debug\u0026quot;: true, \u0026quot;data\u0026quot;: [\u0026quot;The Value of X: \u0026quot;, 85]} {\u0026quot;actiontype\u0026quot;: \u0026quot;log\u0026quot;, \u0026quot;alert\u0026quot;: true, \u0026quot;data\u0026quot;: \u0026quot;Not Logged In\u0026quot;} {\u0026quot;actiontype\u0026quot;: \u0026quot;log\u0026quot;, \u0026quot;data\u0026quot;: \u0026quot;WARNING: x was null\u0026quot;} nop    The nop action does not do anything. Used as a placeholder.\n actiontype - \u0026ldquo;nop\u0026rdquo;  {\u0026quot;actiontype\u0026quot;: \u0026quot;nop\u0026quot;} "},{"id":1,"href":"/reference/actions-advanced/","title":"Actions (Advanced)","parent":"Reference","content":"Hibiki HTML actions are very flexible. Here are some advanced techniques that allow you to mix backend and frontend data, and execute dynamic code.\n   hibikiexpr hibikicontext blobs hibikihandler     hibikiexpr    Most action data can be set as a literal string/object or as a hibikiexpr. A hibikiexpr will be evaluated on the client side. Any data, event, or callpath value can be set to a hibikiexpr.\nHere\u0026rsquo;s an example of incrementing the $.value path by a dynamic amount. We\u0026rsquo;ll set a context variable, and then use the context variable in the 2nd action in an expression to increment $.value:\n{\u0026quot;hibikiactions\u0026quot;:[ {\u0026quot;actiontype\u0026quot;: \u0026quot;setdata\u0026quot;, \u0026quot;setpath\u0026quot;: \u0026quot;@amt\u0026quot;, \u0026quot;value\u0026quot;: 10}, {\u0026quot;actiontype\u0026quot;: \u0026quot;setdata\u0026quot;, \u0026quot;setpath\u0026quot;: \u0026quot;$.value\u0026quot;, \u0026quot;value\u0026quot;: {\u0026quot;hibikiexpr\u0026quot;: \u0026quot;$.value + @amt\u0026quot;}} ]} Here\u0026rsquo;s an example of a conditional expression that sets $.color to red if the new value is less than 0:\n{\u0026quot;hibikiactions\u0026quot;:[ {\u0026quot;actiontype\u0026quot;: \u0026quot;setdata\u0026quot;, \u0026quot;setpath\u0026quot;: \u0026quot;@amt\u0026quot;, \u0026quot;value\u0026quot;: 10}, {\u0026quot;actiontype\u0026quot;: \u0026quot;setdata\u0026quot;, \u0026quot;setpath\u0026quot;: \u0026quot;$.value\u0026quot;, \u0026quot;value\u0026quot;: {\u0026quot;hibikiexpr\u0026quot;: \u0026quot;$.value + @amt\u0026quot;}} {\u0026quot;actiontype\u0026quot;: \u0026quot;setdata\u0026quot;, \u0026quot;setpath\u0026quot;: \u0026quot;$.color\u0026quot;, \u0026quot;value\u0026quot;: {\u0026quot;hibikiexpr\u0026quot;: \u0026quot;$.value \u0026gt;= 0 ? 'black' : 'red'\u0026quot;}} ]} Here we\u0026rsquo;ll update the customer name, and return the full customer object:\n{\u0026quot;hibikiactions\u0026quot;:[ {\u0026quot;actiontype\u0026quot;: \u0026quot;setdata\u0026quot;, \u0026quot;setpath\u0026quot;: \u0026quot;$.customer.name\u0026quot;, \u0026quot;data\u0026quot;: \u0026quot;Mike\u0026quot;}, {\u0026quot;actiontype\u0026quot;: \u0026quot;setreturn\u0026quot;, \u0026quot;data\u0026quot;: {\u0026quot;hibikiexpr\u0026quot;: \u0026quot;$.customer\u0026quot;}} ]} hibikicontext    The optional hibikicontext key along side the hibikiactions key is used to inject context data while running the actions. Any value in the object can be accessed using the \u0026ldquo;@var\u0026rdquo; syntax. This is useful when combined with hibikiexpr values.\nHere\u0026rsquo;s the example from above, but using hibikicontext. @amt is set via hibikicontext:\n{\u0026quot;hibikiactions\u0026quot;:[ {\u0026quot;actiontype\u0026quot;: \u0026quot;setdata\u0026quot;, \u0026quot;setpath\u0026quot;: \u0026quot;$.value\u0026quot;, \u0026quot;value\u0026quot;: {\u0026quot;hibikiexpr\u0026quot;: \u0026quot;$.value + @amt\u0026quot;}} {\u0026quot;actiontype\u0026quot;: \u0026quot;setdata\u0026quot;, \u0026quot;setpath\u0026quot;: \u0026quot;$.color\u0026quot;, \u0026quot;value\u0026quot;: {\u0026quot;hibikiexpr\u0026quot;: \u0026quot;$.value \u0026gt;= 0 ? 'black' : 'red'\u0026quot;}} ], \u0026quot;hibikicontext\u0026quot;: {\u0026quot;amt\u0026quot;: 10} } Here we\u0026rsquo;ll fire an event handler, using data from our frontend data model and our backend action. Value is set from \u0026ldquo;$.value\u0026rdquo; (from the frontend), and mode is set using hibikicontext.\n{\u0026quot;hibikiactions\u0026quot;:[ {\u0026quot;actiontype\u0026quot;: \u0026quot;fireevent\u0026quot;, \u0026quot;event\u0026quot;: \u0026quot;custom1\u0026quot;, \u0026quot;data\u0026quot;: {\u0026quot;hibikiexpr\u0026quot;: \u0026quot;{value: $.value, mode: @mode}\u0026quot;}} ], \u0026quot;hibikicontext\u0026quot;: {\u0026quot;mode\u0026quot;: \u0026quot;compact\u0026quot;} } We can use a dynamic index from hibikicontext to set an array value:\n{\u0026quot;hibikiactions\u0026quot;:[ {\u0026quot;actiontype\u0026quot;: \u0026quot;setdata\u0026quot;, \u0026quot;setpath\u0026quot;: \u0026quot;$.arrdata[@index]\u0026quot;, \u0026quot;data\u0026quot;: 28} ], \u0026quot;hibikicontext\u0026quot;: {\u0026quot;index\u0026quot;: 8} } hibikicontext can also avoid data duplication:\n{\u0026quot;hibikiactions\u0026quot;:[ {\u0026quot;actiontype\u0026quot;: \u0026quot;setdata\u0026quot;, \u0026quot;setpath\u0026quot;: \u0026quot;$.v1\u0026quot;, \u0026quot;data\u0026quot;: {\u0026quot;hibikiexpr\u0026quot;: \u0026quot;@value\u0026quot;}}, {\u0026quot;actiontype\u0026quot;: \u0026quot;setdata\u0026quot;, \u0026quot;setpath\u0026quot;: \u0026quot;$.v2\u0026quot;, \u0026quot;data\u0026quot;: {\u0026quot;hibikiexpr\u0026quot;: \u0026quot;@value\u0026quot;}}, {\u0026quot;actiontype\u0026quot;: \u0026quot;setdata\u0026quot;, \u0026quot;setpath\u0026quot;: \u0026quot;$.v3\u0026quot;, \u0026quot;data\u0026quot;: {\u0026quot;hibikiexpr\u0026quot;: \u0026quot;@value\u0026quot;}} ], \u0026quot;hibikicontext\u0026quot;: {\u0026quot;value\u0026quot;: ... large json value ... } } blobs    It can be easier to return blob data (like images) in the same response as data. To return a blob, use the setdata action, but instead of setting data, use the two special keys blobbase64 and blobmimetype. blobbase64 should be a properly padded Base64 encoding of the blob object, and blobmimetype should be a valid mime type.\n{\u0026quot;hibikiactions\u0026quot;:[ {\u0026quot;actiontype\u0026quot;: \u0026quot;setdata\u0026quot;, \u0026quot;setpath\u0026quot;: \u0026quot;$.img\u0026quot;, \u0026quot;blobmimetype\u0026quot;: \u0026quot;image/jpeg\u0026quot;, \u0026quot;blobbase64\u0026quot;: \u0026quot;...base64 encoded data...\u0026quot;} ] } hibikihandler    Used to return a handler block that will be parsed and evaluated by Hibiki HTML. hibikicontext can be specified for the returned block to allow the backend to inject values.\n{\u0026quot;hibikihandler\u0026quot;: \u0026quot;$.dataval = $.dataval + @inc; fire-\u0026gt;dataupdated($.dataval);\u0026quot;, \u0026quot;hibikicontext\u0026quot;: {\u0026quot;inc\u0026quot;: 5} } "},{"id":2,"href":"/reference/expressions/","title":"Expression Reference","parent":"Reference","content":"Hibiki HTML features a full expression language to bind your HTML to the frontend data model. Some attributes like bind use expressions directly. Other attributes, and style declarations are just plain strings and are not evaluated by default. Any attribute or style property can be evaulated by using a * as it\u0026rsquo;s first character.\nHere are some examples:\nAssuming that $.data = {x: 5, y: 20} # bind expressions are always evaluated: \u0026lt;h-text bind=\u0026quot;$.data.x\u0026quot;\u0026gt;\u0026lt;/h-text\u0026gt;: =\u0026gt; 5 # normal attributes and style properties are not evaluated \u0026lt;div a=\u0026quot;1\u0026quot; style=\u0026quot;font-size: 14px\u0026quot;\u0026gt; =\u0026gt; \u0026lt;div a=\u0026quot;1\u0026quot; style=\u0026quot;font-size: 14px\u0026quot;\u0026gt; # using a * will turn any attribute or style property into an expression # like React, Dashborg will add \u0026quot;px\u0026quot; to numbers for CSS attributes where that makes sense. \u0026lt;td colspan=\u0026quot;*$.data.x\u0026quot;\u0026gt; =\u0026gt; \u0026lt;td colspan=\u0026quot;5\u0026quot;\u0026gt; \u0026lt;div style=\u0026quot;font-size: *$.data.y\u0026quot;\u0026gt; =\u0026gt; \u0026lt;div style=\u0026quot;font-size: 20px\u0026quot;\u0026gt; \u0026lt;div style=\u0026quot;height: *$.data.x + '%'\u0026quot;\u0026gt; =\u0026gt; \u0026lt;div style=\u0026quot;height: 5%\u0026quot;\u0026gt; \u0026lt;div style=\u0026quot;font-weight: *$.data.x \u0026gt; 2 ? 'bold' : 'normal'\u0026quot;\u0026gt; =\u0026gt; \u0026lt;div style=\u0026quot;font-weight: bold\u0026quot;\u0026gt; # inside of a foreach loop, $local is bound to each value in sequence \u0026lt;h-foreach bind=\u0026quot;[1,2,3,$.data.x]\u0026quot;\u0026gt; =\u0026gt; 2 \u0026lt;h-text bind=\u0026quot;$local * 2\u0026quot;\u0026gt;\u0026lt;/h-text\u0026gt; 4 \u0026lt;/h-foreach\u0026gt; 6 10     Specifying Data Paths Literals Operators Functions  fn:compare() fn:sort()   Special Expressions Special Data Roots Handler Action Statements    setdata action setreturn action callhandler action   fireevent action throw action log action if action nop action  expression action         Specifying Data Paths    All data paths start with \u0026ldquo;$\u0026rdquo; or \u0026ldquo;@\u0026rdquo;. $ is used for data roots and @ is for special contextual values.\n $ - Accesses data from the data root (e.g. $.data.rows or $.state.open). @ - Binds to contextual data (e.g. @rownum or @value). $c - Binds to component data (data local to a component) $state - Binds to Hibiki HTML state data (url params, page title, other internal Hibiki HTML data).  After you specify the root, you can access array elements by using square brackets with numeric values ($.array[0], $.array[4], $.array[$.data.index]) and you can access map fields using dot notation or square brackets with string values ($.data.map.x, $.data.map.bar, $.data.map[\u0026quot;y\u0026quot;]).\nLiterals     Strings - can be either single or double quoted. Remember normal HTML entity encoding applies before any Dashborg processing so \u0026amp;quot; becomes a quote character.  Double Quoted - Allow escapes using \\. Use \\n for newlines (n, b, f, r, t, v are valid escapes). Can also be used to escape any other character (most useful for escaping double quotes \u0026quot;). Single Quoted - No escapes allowed.   Numbers - integers and floating point numbers, base 10 format, no exponents. (regexp: /[-+]?[0-9]*\\.?[0-9]+/). Arrays - Use square brackets, comma separated values, trailing comma is okay. ([2, \u0026quot;hello\u0026quot;, 5, ]). Maps - Use braces, colon after keys, commas between key-values, trailing comma is okay. Use quotes for keys that are not identifier safe. ({x: 5, \u0026quot;abc#foo\u0026quot;: 10}). true, false - for boolean values. null - no value noattr - special null value that when passed as an attribute makes it appear that the attribute was not specified (see noattr/isnoattr below). Note that true, false, and null, are keywords (not allowed for identifiers, dot-notation, or unquoted map keys).  Operators    These are the supported Dashborg operators, listed in increasing precedence order:\n   Operator Type Op Notes     Ternary Conditional ? : [conditional-expression] ? [true-value] : [false-value]   NullishCoalescing ?? Like ```   Logical Or || Short circuits. Returns first truthy value, or false   Logical And \u0026amp;\u0026amp; Short circuits. Returns first value if falsey, otherwise returns second value.   Equality ==, != Shallow equality tests   Relational \u0026gt;=, \u0026lt;=, \u0026gt;, \u0026lt;    Comparison \u0026lt;=\u0026gt; returns -1, 0, or 1, if first argument is less than, equal to, or greater than second element (respectively)   Additive +, - + will work with strings for concatenation   Multiplicative *, /, %    Unary !, -, +     Functions    To call a function you use fn:[function-name]([arguments]), e.g. fn:len($.data.expr). Function names are not case sensitive.\n   Function Notes     fn:len arrays: length, objects/maps: number of keys, scalars: 1, null: 0   fn:indexof calls arg1.indexOf(arg2, [arg3]). Works for both strings and arrays. See String.indexOf   fn:min minimum of all arguments   fn:max maximum of all arguments   fn:floor Math.floor   fn:ceil Math.ceil   fn:slice Like the JavaScript slice function. First argument is an array, 2nd is start element (inclusive), 3rd element is the end element (exclusive). See Array.slice.\nIf you pass a named argument \u0026lsquo;makerefs\u0026rsquo; it will return an array of references to the original array.   fn:splice Like the JavaScript splice function, but does not modify the first argument, will return the newly spliced array. See Array.splice   fn:push Pushes values to the end of an array. Does not modify the input array, will return the new array.   fn:pop Pops a value off the end of an array. Does not modify the input array, will return the new array.   fn:setadd First argument is an array, will conditionally the rest of the arguments to the array if they are not already in the array (checked with \u0026ldquo;==\u0026quot;). Returns a new array. Useful for manipulating checkbox groups, or multi-select values.   fn:setremove First argument is an array, will conditionally remove the rest of the arguments from the array if they are present. Returns a new array.   fn:sethas First argument is an array, will check if the 2nd argument is inside the array (checked with \u0026ldquo;==\u0026quot;). Returns true/false.   fn:int converts argument to integer (truncates floats and converts strings to integer or NaN). See parseInt   fn:float converts argument to floating point number (converts strings to float or NaN). See parseFloat   fn:str converts its argument to a string   fn:bool converts argument to boolean   fn:js call an external js function. 1+ arguments, first argument is a string, rest of the args get converted to a parameter list. window[arg1].apply(null, args2-n)   fn:jseval evaluates its argument as javascript. calls eval(arg1).   fn:merge merges two objects together. Keys from righmost arguments replace keys from leftmost arguments   fn:split splits a string into an array. 1st argument is string to split, 2nd argument is string to split on. See split   fn:ts equivalent to javascript Date.now() (unix timestamp in milliseconds)   fn:now equivalent to javascript Date.now() (unix timestamp in milliseconds)   fn:substr arg1.substr(arg2, arg3). See substr   fn:sprintf sprintf(arg1, \u0026hellip;)   fn:startswith arg1.startsWith(arg2)   fn:endswith arg1.endsWith(arg2)   fn:uppercase returns string value to uppercase   fn:lowercase returns string value to lowercase   fn:match creates a regex with arg2 and and arg3 as options. tries to match arg1. e.g. arg1.match(new Regexp(arg2, arg3))   fn:trimindent fn:trimindent(string), removes constant left indentation from a string   fn:replace fn:replace(string, find-string, replace-string), replaces the first occurance of \u0026lsquo;find-string\u0026rsquo; in \u0026lsquo;string\u0026rsquo; with \u0026lsquo;replace-string\u0026rsquo; (no regex support)   fn:replaceall fn:replaceall(string, find-string, replace-string), replaces all the occurances of \u0026lsquo;find-string\u0026rsquo; in \u0026lsquo;string\u0026rsquo; with \u0026lsquo;replace-string\u0026rsquo; (no regex support)   fn:uuid creates a UUIDv4   fn:json converts its argument to JSON   fn:jsonparse parses argument from JSON to an object   fn:objkeys returns an array of all non-@-keys in the object   fn:objatkeys returns an array of all @-keys in the object   fn:objallkeys returns all keys in object (both regular and @-keys)   fn:filter fn:filter(array, lambda) calls lambda on each element (@elem, @index), removes items where lambda is not true   fn:map fn:map(array, lambda) maps an array by calling lambda on each element (@elem, @index)   fn:find fn:find(array, lambda, [fromindex]), calls lambda (@elem, @index) on each element starting from fromindex (default 0), returns first element that returns true   fn:findindex same as fn:find, but returns index, or -1 if not found   fn:reduce fn:reduce(array, lambda), reduces array using lambda (left reduce)   fn:reverse fn:reverse(array, makerefs=false), returns a reversed array. if makerefs is true, will create references to the original array (not copying values)   fn:every fn:every(array, lambda), returns true if calling lambda (@elem, @index) on every element returns true. calling on empty array or null returns true. calling on non-array (e.g. string or object) returns false.   fn:some fn:some(array, lambda), returns true if at least one element in the array has the lambda (@elem, @index) evaluate to true. empty arrays will return false (no element matches)   fn:concat concatenates arrays together. all arguments must be arrays or null. null values are skipped.   fn:join fn:join(array, string), joins array elements together using string as the separator   fn:shift returns a new array where the first element is removed   fn:unshift fn:unshift(array, elem, [elem2], [elem3]\u0026hellip;) returns a new array where the elements passed are added to the front of the array (not reversed)   fn:bloblen returns length of blob (deprecated, use @blob.bloblen)   fn:blobmimetype returns blob mimetype (deprecated, use @blob.mimetype)   fn:blobastext returns text version of blob (only if mimetype starts with \u0026ldquo;text/\u0026quot;)   fn:blobasbase64 returns base64 encoded version of blob (deprecated, use @blob.base64)   fn:blobname returns the file name from the blob object (deprecated, use @blob.name)   fn:deepequal 2 arguments, return true/false if they are deeply equal   fn:deepcopy creates a deepcopy of arguments (not usually necessary since Hibiki makes a copy automatically, except when dealing with references)   fn:compare (see compare documentation below)   fn:sort (see sort documentation below)    fn:compare()    Requires 2 arguments, the two values to be compared. Returns -1, 0, or 1 if the first argument is less than, equal to, or greater than the 2nd argument (respectively). The named parameters affect the comparison:\nNamed Parameters:\n type (string) - \u0026ldquo;numeric\u0026rdquo; or \u0026ldquo;string\u0026rdquo;. if null, the comparison will be based on the types of the arguments. If both are numbers, then it will be a numeric comparison, otherwise string. nulls will always sort before any value in either type. locale (string) - override the locale of the comparison (otherwise uses the browser\u0026rsquo;s locale value). e.g. for french should use \u0026ldquo;fr\u0026rdquo;. sensitivity (string) - \u0026ldquo;base\u0026rdquo;, \u0026ldquo;accent\u0026rdquo;, \u0026ldquo;case\u0026rdquo;, or \u0026ldquo;varient\u0026rdquo;. See Intl Collator Docs. By default it is set to \u0026ldquo;varient\u0026rdquo;, but other sensitivity types allow different characters to be treated as equal. nocase - sets sensitivity to \u0026ldquo;accent\u0026rdquo; (sensitivity option takes precendence). this makes the comparison case-insensitive. field - if both arguments are objects, compares the sub-field named field within them. e.g. if you call fn:compare($.foo, $.bar, field=\u0026lsquo;test\u0026rsquo;), it will compare $.foo.test with $.bar.test. if argument is null, or does not contain the specified field, will compare against null. index - if both arguments are arrays, compares the sub-index index within them. e.g. if you call fn:compare($.foo, $.bar, index=8), it will compare $.foo[8] with $.bar[8]. if argument is null, or does not contain the specified index, will compare against null.  fn:compare($.v1, $.v2, type=\u0026quot;numeric\u0026quot;) # force numeric comparison fn:compare($.v1, $.v2, type=\u0026quot;string\u0026quot;, nocase=true) # force case-insensitive string comparison fn:compare($.v1, $.v2, field=\u0026quot;qty\u0026quot;, type=\u0026quot;numeric\u0026quot;) # numeric comparison between $.v1.qty and $.v2.qty # compare $.v1.name with $.v2.name, using rules from french locale. # comparison will be case-insensitive and will ignore accents fn:compare($.v1, $.v2, field=\u0026quot;name\u0026quot;, locale=\u0026quot;fr\u0026quot;, sensitivity=\u0026quot;base\u0026quot;) fn:sort()    Requires 1 argument, the data to be sorted. Returns a new array where the input data is sorted according to the provided arguments.\nNamed Parameters:\n data (array) - the data to be sorted. can also be passed as the first positional argument. sortexpr (lambda) - a lambda expression that overrides the built in compare function. Gets two context variables @a (first value), and @b (second value). Should return -1, 0, or 1. desc (boolean) - if true, will reverse the sort order makerefs (boolean) - if true, will create a sorted array of references that point back to the original array elements. slice ([number, number]) - a one or two element array to slice the final array. same arguments as fn:slice(). nosort (boolean) - if set to true, do not sort the array (just return a copy). (any parameter that can be passed to fn:compare) - these parameters are passed to fn:compare() when comparing values. not used if sortexpr is provided.  fn:sort($.data) // sorts data naturally using fn:compare() function fn:sort($.data, field=\u0026quot;qty\u0026quot;, type=\u0026quot;numeric\u0026quot;) // sort objects using field \u0026quot;qty\u0026quot; numerically fn:sort($.data, makerefs=true) // returns array of references to original array fn:sort($.data, field=\u0026quot;qty\u0026quot;, desc=true) // sort objects using field \u0026quot;qty\u0026quot;, reverse order fn:sort($.data, slice=[10,20]) // sort data naturally, return elements 10-19 Special Expressions       Expression Notes     ref(path-expr) creates a reference to the given path. can only accept global or component paths ($) or ($c).   isref(expr) returns true/false if the expression is a reference   refinfo(expr) if expr is a reference returns a string showing what it references, otherwise null   raw(expr) normally references are automatically de-referenced (so they are transparent). using the expression raw() will keep them from being evaluated. useful for passing references to a sub-component.   noattr the special constant meaning \u0026ldquo;no attribute\u0026rdquo;. generally in most user expressions it is equivalent to null. however for some components passing an argument equal to \u0026ldquo;null\u0026rdquo; or not passing any argument is different. The \u0026ldquo;noattr\u0026rdquo; expression allows you to propagate the \u0026ldquo;no attribute\u0026rdquo; to a sub-component.   isnoattr(expr) returns true/false if the expr is equal to \u0026ldquo;noattr\u0026rdquo;. you cannot distinguish \u0026ldquo;noattr\u0026rdquo; with \u0026ldquo;==\u0026rdquo; because noattr == null (and vice versa).   lambda(expr) creates a special lambda value of the given expression. lambda values are not evaluated until they are invoked. They will only have access to the context data that is passed in during invoke. Any other data references (e.g. to global data, component data, or current context data) will be undefined.   invoke(lambda, params) invokes a lambda. params are context variables to be passed into the expression    Special Data Roots       Data Root Notes     $ Alias for $data (global data root)   @ Alias for $context   $c Component root data (data local to the current component) - alias for $component   $data Returns root of frontend data model (global root)   $component Component root data (data local to the current component)   $state Returns Hibiki state data (used for interacting with internal Hibiki HTML state)   $context Returns contextual data \u0026ndash; e.g. iteration index (@index), or input value in data (@value). $context.value is the same as @value.   $contextstack Returns an array (stack) of context data. Used for nested loops to access outer loop\u0026rsquo;s data. $context is the same as $contextstack[0] (enclosing contexts have larger indexes). $contextstack[0].value is the same as @value.    Handler Action Statements    Hibiki HTML handlers (handler, click.handler, change.handler, mount.handler, init.handler, etc.) execute actions. The Hibiki HTML parser will convert these action statements into Hibiki Actions. Every action that can be parsed can also be represented as JSON and vice-versa.\nStatements must be separated with a ;. Trailing ; is allowed.\nsetdata action    Used to set values into the data model. Note you can only set values into $data ($), $state, or $context (@). Context values are local to the handler block (just used for temporary variables).\n$state.x = 5; $.job = {jobid: 22, jobname: \u0026quot;Test Job\u0026quot;}; @temp = 5 * $state.val; @temp2 = @temp * @temp; $.newval = @temp2; @foo = /test/handler; setreturn action    Used to return values from a handler. Does not terminate the running handler, just sets the return value.\nsetreturn(5); setreturn({x: 10, y:20}); setreturn(null); callhandler action    Call handlers always start with /. They consist of 3 parts, an optional module, an optional path, and an optional path fragment. Either module or path must be specified (path will default to /).\n/@[module-name]/[path]:[pathfrag] Handlers can take an optional parameter list of data. Data is specified as key = value pairs separated by commas (trailing commas are allowed). Positional parameters are also allowed before any key/value pairs, and will be placed into a special data key named *args. Some handlers allow special \u0026lsquo;@'-key parameter values..\nHere are some example paths, with and without arguments:\n# simple path, no module, no arguments /handler/path # 'fetch' module, 'get' pathfrag, path defaults to '/'. # 1 positional argument, 3 key-value arguments passed. 'x', and 'y' are normal, @method is a special parameter /@fetch:get('/api/test', @method='post', x=10, y=20) # no module, 2 positional parameters, one key-value parameter /complex/run-handler(5, 10, userid=$.userid); # can assign the return value from handlers to the data model $.index = /api/get-index(partid=22) # using the 'call' keyword, we can construct dynamic call paths # arguments and return values work the same. call \u0026quot;/test-handler\u0026quot; (x=10, @method='post'); call \u0026quot;/test\u0026quot; + $state.handlername, (x = $state.x, y = $state.y); @rtnval = call \u0026quot;/test/handler\u0026quot;; Note that handlers are not expressions, so only simple assignment works, you can\u0026rsquo;t write @foo = /test + 5.\nfireevent action    Fire an event that triggers event handlers. Parameters can be name-value pairs which will create context (@vars) in the callee. A single positional parameter will set the \u0026lsquo;value\u0026rsquo; key. Adding the @bubble at-param will make the event bubble.\nfire-\u0026gt;click; fire-\u0026gt;custom1(); fire-\u0026gt;submit(itemid=22, price=100, @bubble=true) fire-\u0026gt;custom2(@bubble=true); fire-\u0026gt;custom3(88) throw action    Throws an error. Takes one argument which will be evaluated as a string (the error message):\nthrow(\u0026quot;Invalid User Id\u0026quot;); throw(\u0026quot;No value is set\u0026quot;); log action    Logs a sequence of positional arguments to the JavaScript console. If @debug is true, it will output extra debugging information and a Hibiki/JavaScript call stack. If @alert is true, it will cause a browser alert.\nlog(\u0026quot;the value is\u0026quot;, $.value); log(\u0026quot;show stack trace\u0026quot;, @debug=true); log(\u0026quot;Not Logged In!\u0026quot;, @alert=true); if action    if/then/else implementation. Parenthesis around the conditional expression, Braces are required around the then/else statement blocks, else statement is optional. If statements require a ; to separate them from subsequent statements;\nif ($.primary) { $.openpopup = true; }; if ($.color == 'blue') { $.blue = true } else { $.red = true }; nop action    Does nothing.\nnop; nop(); expression action    Raw expressions can be statements. This is only useful if your expression has side effects. Useful in conjunction with fn:js. There is no \u0026ldquo;expr\u0026rdquo; JSON action, instead you can use a \u0026ldquo;setdata\u0026rdquo; action with a null setpath.\nexpr fn:js('external_fn_name', 55); expr fn:js('alert', 'hello'); "},{"id":3,"href":"/reference/core-tags/","title":"Core Tags","parent":"Reference","content":"  Node Tags  \u0026lt;h-text\u0026gt; \u0026lt;h-fragment\u0026gt; \u0026lt;h-dyn\u0026gt; \u0026lt;h-children\u0026gt; \u0026lt;h-watcher\u0026gt;   Definition Tags  \u0026lt;script\u0026gt; \u0026lt;define-vars\u0026gt; \u0026lt;define-handler\u0026gt; \u0026lt;define-component\u0026gt; \u0026lt;import-library\u0026gt;     Node Tags    \u0026lt;h-text\u0026gt;    Renders text content. If class/style are not specified, it will render as a DOM text node. If you provide values for class or style, it will render as a \u0026lt;span\u0026gt; with class and style set.\n{{ expr }} is equivalent to \u0026lt;h-text bind=\u0026ldquo;expr\u0026rdquo;\u0026gt;\u0026lt;/h-text\u0026gt;.\nAttributes\n bind (value) - the value to render format (string) - how to format the value (default is just converting value to a string). see below. class (string) - class value style (string) - style value   format attribute is a sprintf like format specifier. uses the sprintf-js library to render output. Also support three special values \u0026ldquo;json\u0026rdquo;, \u0026ldquo;json-compact\u0026rdquo;, and \u0026ldquo;json-noresolve\u0026rdquo; to format the given value as JSON.\n\u0026lt;h-fragment\u0026gt;    Groups a set of children. Does not render as any tag (removed from the output). Useful when combined with other attributes like if or foreach.\nAttributes:\n [children] - the children to render   \u0026lt;h-dyn\u0026gt;    Dynamically parses and renders Hibiki HTML content. Renders the same as \u0026lt;h-fragment\u0026gt;. On a parse error it will not render any output and report an error.\nAttributes\n bind (string) - the HTML text to parse/render.   \u0026lt;h-children\u0026gt;    Renders children passed to components. Normally passed @children or a filtered set of children nodes. The children are rendered in their original parent\u0026rsquo;s data context. So children do not have access to $c or any component context variables.\nIn order to pass data from the component to the child you must inject attributes (similar to how higher order components work in React, but much easier to implement in Hibiki HTML).\nAttributes\n text (string) - if text is not null, will not render any children and render the given text instead. bind (children) - the children to render. If bind attribute is not passed, if it evaluates to null or if there are zero children to render, it will instead render its own children. [children] - used when bind is not set, is null, or contains zero children inject:* - attributes to inject into the rendered children (see injection below). datacontext - additional context (@vars) to set when rendering children. acts as if an extra \u0026lt;define-vars\u0026gt; was run right before rendering the child.   When the bind attribute is not provided, is null, or there are zero children to render, \u0026lt;h-children\u0026gt; renders its own children. This is useful when writing a component that has a default UI, and can be optionally overwritten by content passed to your component (e.g. in a special \u0026ldquo;slot\u0026rdquo; child). This is also useful if you want to inject attributes into a group of child nodes.\nInjection - injected attributes overwrite any value that is already present in the child (they are not merged). If the injected attribute is an expression (starts with *) then it will have access to a special @node context variable representing the child node that is being injected. Using the @node.attrs you can inject dynamic attributes into the node. @node contains the fields:\n tag - the node\u0026rsquo;s tag name rawtag - raw tag name (useful if the component attribute or \u0026ldquo;html-\u0026rdquo; prefix was used to transform the tag) uuid attrs - the resolved attributes of the node (not including injected attributes) children - \u0026lsquo;children\u0026rsquo; variable for the child node  Note \u0026lt;h-children\u0026gt; does not support the foreach attribute.\n# most common useage, just render all children as-is \u0026lt;h-children bind=\u0026quot;@children\u0026quot;\u0026gt;\u0026lt;/h-children\u0026gt; # if $args.label is set, it will render that value as text. # if a children with 'slot' equal to 'label' are passed, it will render those children # otherwise it will evaluate to the text '[No Label]' \u0026lt;h-children text=\u0026quot;$args.label\u0026quot; bind=\u0026quot;@children.byslot['label']\u0026quot;\u0026gt;[No Label]\u0026lt;/h-children\u0026gt; # will render the \u0026lt;input\u0026gt; tag with value set to 'mike' and with blue text style \u0026lt;h-children inject:value=\u0026quot;mike\u0026quot; inject:style=\u0026quot;color: blue;\u0026quot;\u0026gt; \u0026lt;input type=\u0026quot;text\u0026quot;\u0026gt; \u0026lt;/h-children\u0026gt; # renders the first \u0026lt;input\u0026gt; child. injects a change handler \u0026lt;h-children inject:change.handler=\u0026quot;$c.value = @value;\u0026quot; bind=\u0026quot;@children.bytag['input'].first\u0026quot;\u0026gt;\u0026lt;/h-children\u0026gt; # advanced usage. select 'column' elements from the library named 'mylib'. # in the first call, inject the attribute \u0026quot;header\u0026quot; and render them # in the second call, render the children for each row and inject the 'row' object # note that we're using \u0026lt;html-tr\u0026gt; because in HTML, standard \u0026lt;tr\u0026gt; tags cannot accept non-\u0026lt;td\u0026gt; children. # could also have written it as \u0026lt;tr\u0026gt;\u0026lt;td component=\u0026quot;h-children\u0026quot; ...\u0026gt;\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt; \u0026lt;html-tr\u0026gt; \u0026lt;h-children bind=\u0026quot;@children.bycomp['mylib:column']\u0026quot; inject:mode=\u0026quot;header\u0026quot;\u0026gt;\u0026lt;/h-children\u0026gt; \u0026lt;/html-tr\u0026gt; \u0026lt;html-tr foreach=\u0026quot;(@row, @idx) in $args.rows\u0026quot;\u0026gt; \u0026lt;h-children bind=\u0026quot;@children.bycomp['mylib:column']\u0026quot; inject:mode=\u0026quot;row\u0026quot; inject:row=\u0026quot;*raw(@row)\u0026quot; inject:rownum=\u0026quot;*@idx\u0026quot;\u0026gt;\u0026lt;/h-children\u0026gt; \u0026lt;/html-tr\u0026gt; \u0026lt;h-watcher\u0026gt;    Allows you to watch a value or expression and fire a handler any time the value changes. Care should be taken to not create infinite loops by modifiying the value you are watching in the update handler.\nNormally Hibiki HTML nodes are reactive to their data already, but \u0026lt;h-watcher\u0026gt; allows you to bridge that reactivity into non-Hibiki code or AJAX requests.\nAttributes\n bind - The value to watch. Can be a simple path like $.data.name or a complex value (to watch multiple paths): [$.data.name, $.data.id]. fireoninit - if true, will fire when the watcher is first initialized, otherwise the initial value does not fire the change event.   Events\n change - Fired whenever the watched value changes. @value will be set to the watched value.   Definition Tags    \u0026lt;script\u0026gt;    Script tags work in a special way in Hibiki HTML. When \u0026ldquo;rendered\u0026rdquo; their src or text content is compared against a cache of already rendered script tags. If the value is found, nothing happens, otherwise the script src or content is run.\nAttributes\n src - script src (also can specify text content as a child) async - run the script tag synchronously or asynchronously. If not async, loading the script will block the library load or your app\u0026rsquo;s \u0026ldquo;init\u0026rdquo; event. Useful when you need a library loaded to use your app or library (e.g. d3). [textbody] - script text (when src is not specified)   Often it is easier (when not in a library) to load your scripts outside of the Hibiki tag which will naturally block your app until the script is loaded.\n\u0026lt;define-vars\u0026gt;    Creates a new set of context variables (@vars) that can be used by the siblings following the \u0026lt;define-vars\u0026gt; and their descendents. A define-vars expression is just a sequence of simple assignments (it does not support any other type of statement). When you re-define a variable that already exists, it masks the old one in the current scope. The old value will be available when this define-vars goes out of scope.\nAttributes\n datacontext - the variables to assign (as an attribute) [textbody] - the variables to assign (as body text)   Allowed Define Vars:\n# can assign using @ or without # can access global scope # can separate assignments with \u0026quot;,\u0026quot; or with \u0026quot;;\u0026quot; (or mixed) # new variables can reference variables just created (using @) or previously defined @vars \u0026lt;define-vars\u0026gt; x=5, y = @x*2; @z = {name: \u0026quot;mike\u0026quot;, id: $.global_id} \u0026lt;/define-vars\u0026gt; # can use attribute 'datacontext' # can access $args and $c \u0026lt;define-vars datacontext=\u0026quot;value = raw($args.value) ?? ref($c.value)\u0026quot;\u0026gt;\u0026lt;/define-vars\u0026gt; Invalid Define Vars:\n\u0026lt;define-vars\u0026gt; $.x = 5; # cannot set variables in $ or $state scopes @foo.x = 10; # cannot assign to sub-indexed variables if ($.x) { # invalid statement, can only do simple assignments @bar = 10; } log(@foo); # non-assignment statement @x = //@local/assign-value(); # cannot call handlers \u0026lt;/define-vars\u0026gt; \u0026lt;define-handler\u0026gt;    Defines a handler. The text body of the tag is parsed as the handler definition.\nAttributes:\n name - name of handler (either //@local/[name] or //@event/[name]). [textbody] - the Hibiki HTML code that defines the handler   \u0026lt;define-component\u0026gt;    Defines a component. The children tags are parsed as the component definition.\nAttributes:\n name - name of handler (either //@local/[name] or //@event/[name]). componentdata - datacontext to initialize the $c root [children] - component definition   \u0026lt;import-library\u0026gt;    Contains components, handlers, and other definitions for a library.\nAttributes:\n name - name of library [children] - components, handlers, \u0026lt;script\u0026gt;, \u0026lt;link\u0026gt; (css)   "},{"id":4,"href":"/reference/hibiki-module/","title":"Hibiki Module","parent":"Reference","content":"  The hibiki module is used for misc functionality that accesses some built in browser functionality. To call a hibiki module function use //@hibiki/[fn-name](args).\n   Handler Example Description     /sleep //@hibiki/sleep(100) sleeps for given number of ms   /alert //@hibiki/alert(\u0026quot;hello\u0026quot;) calls the browser alert function with the given argument   /confirm @ok = //@hibiki/confirm(\u0026quot;Are you sure?\u0026quot;) calls the browser confirm function with the given argument. returns true/false   /set-session-storage //@hibiki/get-session-storage(key='test') retrieves the given session storage key, value will be parsed as JSON and returned as an object. if storage is not valid JSON will return null.   /get-session-storage //@hibiki/set-session-storage(key='test', value='hello')  sets the given session storage key to the given value. value will be converted to JSON (error if it cannot be converted). if value is \u0026lsquo;null\u0026rsquo; the key will be removed.   /set-title //@hibiki/set-title('New Title') Sets the page title in browser (equivalent to calling document.title = value)   /update-url //@hibiki/update-url(@path='/test', @title=\u0026quot;New Title\u0026quot;, @replace=false, arg1=10) Updates the browser URL to @path (using HTML5 history API, does not navigate the browser). calls pushState by default, or replaceState if @replace=true. @title is optional, and will set document.title if given. Non @-args will be set as parameters on the given @path.   /navigate //@hibiki/navigate(@path='/test', arg1=10, y=20) will navigate the browser to the given @path (by setting window.location). the non-@-args will be set as query parameters on the URL.   /set-timeout //@hibiki/set-timeout(\u0026quot;tevent\u0026quot;, 1000, arg=5, y=10) Calls the given event after the given number of milliseconds. The named arguments are passed as event arguments   /set-interval @id = //@hibiki/set-interval(\u0026quot;ievent\u0026quot;, 1000, arg=5, y=10) Calls the given event every N milliseconds. The named arguments are passed as event arguments. Will call forevery until cleared using clear-interval with the returned id   /clear-interval //@hibiki/clear-interval(@id) Stops a set-interval from firing (also works with unfired set-timeouts). Must pass the id that is returned from set-interval or set-timeout    "},{"id":5,"href":"/reference/special-types/","title":"Special Types","parent":"Reference","content":"    Children Var Hibiki Blob     Children Var    Children Var is passed as @children to all components (available inside of a \u0026lt;define-component\u0026gt; block). It contains all the evaluated children of the component. You must pass a valid ChildrenVar object to the bind expression of \u0026lt;h-children\u0026gt;. Because most of the getters return ChildrenVar objects they can be chained.\nExamples:\n// access children by slot. // \u0026quot;.noslot\u0026quot; will find children not tagged with a slot // \u0026quot;.byslot\u0026quot; will access children tagged with the given slot name \u0026lt;h-children bind=\u0026quot;@children.noslot\u0026quot;\u0026gt;\u0026lt;/h-children\u0026gt; \u0026lt;h-children bind=\u0026quot;@children.noslot.tags\u0026quot;\u0026gt;\u0026lt;/h-children\u0026gt; \u0026lt;h-children bind=\u0026quot;@children.byslot['head']\u0026quot;\u0026gt;\u0026lt;/h-children\u0026gt; // only children which are 'tags' (filters out text/comments) \u0026lt;h-children bind=\u0026quot;@children.tags\u0026quot;\u0026gt;\u0026lt;/h-children\u0026gt; // children by index, or first child \u0026lt;h-children bind=\u0026quot;@children.byindex[0]\u0026quot;\u0026gt;\u0026lt;/h-children\u0026gt; \u0026lt;h-children bind=\u0026quot;@children.first\u0026quot;\u0026gt;\u0026lt;/h-children\u0026gt; // children by tag name // for libraries use bycomp['[lib-name]:[comp-name]'] \u0026lt;h-children bind=\u0026quot;@children.bytag['a']\u0026quot;\u0026gt;\u0026lt;/h-children\u0026gt; \u0026lt;h-children bind=\u0026quot;@children.bycomp['hibiki/bulma:option']\u0026quot;\u0026gt;\u0026lt;/h-children\u0026gt;    Property Description     size number of children   noslot returns children not tagged with a slot name (includes text/whitespace/comment nodes)   tags filters children to only include children which are tags (excludes text and whitespace)   first returns first child   byindex returns an array of childrenvar objects, each with one child (by index)   bytag returns an object mapping tag names to childrenvars   bycomp returns an object mapping \u0026lsquo;[lib-name]:[comp-name]\u0026rsquo; to children vars (useful for libraries to find their own components   node returns a NodeVar object of the first child   nodes returns an array of NodeVar objects   filter advanced. takes a lambda, calls it for each child (@node=NodeVar) and returns a new childrenvar object of the matching nodes   all all the children (noop), deprecated (for historical purposes)    Hibiki Blob    Hibiki Blob can represent images, videos, text, etc. They can be displayed by the appropriate tag (img, video, etc.) or downloaded by the user. They are stored as base64 dataurl values.\n   Property Description     mimetype the mimetype of the blob, e.g. \u0026lsquo;text/csv\u0026rsquo;, \u0026lsquo;image/jpeg\u0026rsquo;   bloblen size of blob (bytes)   name name of blob - not all blobs have names. usually a name comes from a file upload input and will contain the uploaded file name   base64 base64 string representation of the blob   text (v0.3.5) if the blob has mimetype of \u0026lsquo;text/*\u0026rsquo; will return the text content of the blob    "},{"id":6,"href":"/reference/js-api/","title":"JS API","parent":"Reference","content":"    HibikiGlobalConfig HibikiState Getting / Setting Data Registering JS Handlers     Hibiki is designed so that for simple projects you should not need to ever write a line of JavaScript. However, there are times when you may need to interact with existing JS code, or an existing JS library where there is a need to bridge data and functionality between Hibiki and the browser\u0026rsquo;s JS layer (especially when writing your own Hibiki libraries).\nThe Hibiki JS API allows you to interact with your running Hibiki code by:\n Getting data from the Hibiki data model Setting data into the Hibiki data model (potentially causing the UI to update) Watching for Hibiki data model changes (getting notified via a callback) Registering functions that can be called as Hibiki handlers Registering functions that can be called as Hibiki expressions  HibikiGlobalConfig    To update Hibiki settings before the Hibiki applications are rendered you can define a global JS object called HibikiGlobalConfig. It can be used to set global options that affect the rendering of the Hibiki tags, as well as firing callbacks when the Hibiki applications are initialized. It provides two hooks related to application lifecycle preRenderfHook and postRenderHook. The preRenderHook is called right after the application is initialized but before the initial UI rendering. The postRenderHook is called after the first successful UI render. Both hooks are called with 2 elements, the HibikiState object, and the HTMLElement that the UI will be rendered into.\nHibikiState    Every \u0026lt;template hibiki\u0026gt; element is controlled by its own HibikiState object. The HibikiState object contains the controller for the UI, and the data that is used to render the UI. You use the HibikiState object to interact with your Hibiki application.\nHibiki applications are initialized after the DOMContentLoaded event is fired (unless you manually create and initialize your applications). So any interaction with the HibikiState objects should also wait until after they are initialized.\nThe easiest way to get a HibikiState object is via the global variable window.HibikiState. This works great for most cases when there is only one Hibiki application defined on a page (it will always be set to the last Hibiki application that was initialized on a page).\nWhen there are multiple application on one page, you can add a name attribute to any of your Hibiki tags, e.g. \u0026lt;template hibiki name=\u0026quot;test1\u0026quot;\u0026gt; and \u0026lt;template hibiki name=\u0026quot;test2\u0026quot;\u0026gt;. Now to access those states you can use the window.Hibiki.States global variable (which is an object that maps names to HibikiState objects). So test1\u0026rsquo;s state can be accessed as window.Hibiki.States[\u0026quot;test1\u0026quot;]. As States is just a plain JS object, it can also be looped over to find all of your named states. Note that Hibiki tags without a name attribute will not be added to States.\nGetting / Setting Data    Once you have a HibikiState object you can get data from the data-model using state.getData(path) and set data using state.setData(path, data).\nThis example shows how to test and set $.color in the Hibiki data model from JavaScript before the application is rendered.\n// hooks get called with (state, htmlelem) function setDefaultColorHook(state) { let currentColor = state.getData(\u0026quot;$.color\u0026quot;); if (currentColor == null) { state.setData(\u0026quot;$.color\u0026quot;, \u0026quot;green\u0026quot;); } } window.HibikiGlobalConfig = { preRenderHook: setDefaultColorHook, }; This example shows how you could update the Hibiki data model from a click handler attached to a external HTML element. Note that you should never manually attach an event listener to an element that is controlled by Hibiki, only elements that are outside of the Hibiki application:\nfunction externalUpdateColor() { let state = window.HibikiState; // gets the HibikiState object state.setData(\u0026quot;$.color\u0026quot;, \u0026quot;red\u0026quot;); } document.getElementById(\u0026quot;mybutton\u0026quot;).addEventListener(\u0026quot;click\u0026quot;, externalUpdateColor); In the console (to inspect/set data):\n// dumps the entire global Hibiki data model HibikiState.getData(\u0026quot;$\u0026quot;); // dump the value stored in $.color to the console HibikiState.getData(\u0026quot;$.color\u0026quot;); // update the color HibikiState.setData(\u0026quot;$.color\u0026quot;, \u0026quot;purple\u0026quot;); Registering JS Handlers    Registering JS handlers allows you to call some JavaScript code directly from your Hibiki application as a \u0026ldquo;handler\u0026rdquo;. Note that local handlers can be registered at any time after the Hibiki \u0026lt;script\u0026gt; tag has been included. Handlers get passed one argument, a HibikiRequest object that contains the data passed to the handler as well as other metadata.\nJust like normal Hibiki handlers, the handler can be pure and only return data, or it can contain actions which operate on the data-model directly.\nHere\u0026rsquo;s an example:\n// this handler operates on the data model directly by calling req.setData window.Hibiki.registerLocalJSHandler(\u0026quot;/set-color-red\u0026quot;, (req) =\u0026gt; { req.setData(\u0026quot;$.color\u0026quot;, \u0026quot;red\u0026quot;); }); window.Hibiki.registerLocalJSHandler(\u0026quot;/get-data\u0026quot;, (req) =\u0026gt; { // can run any JS here. the return value will be // available to the Hibiki code as the return value of the handler. // req.data is set as an object containing the data parameters passed to the handler. return {x: req.data.val + 5, y: 10}; }); window.Hibiki.registerLocalJSHandler(\u0026quot;/get-promise-data\u0026quot;, (req) =\u0026gt; { // if you return a Promise, it will be awaited and resolved return fetch('/some/api').then((resp) =\u0026gt; resp.json()); }); Once you\u0026rsquo;ve registered a handler it can be called from inside of your Hibiki code by using //@local/[handler-path] just as if it was defined using a \u0026lt;define-handler\u0026gt; tag:\n\u0026lt;!-- this handler calls req.setData directly, so it updates the data-model --\u0026gt; \u0026lt;a click.handler=\u0026quot;//@local/set-color-red()\u0026quot;\u0026gt;Set Red\u0026lt;/a\u0026gt; \u0026lt;!-- here we're passing x=10 into get-data. It will return {x: 15, y:10} --\u0026gt; \u0026lt;a click.handler=\u0026quot;$.mydata = //@local/get-data(x=10)\u0026quot;\u0026gt;Get Data\u0026lt;/a\u0026gt; \u0026lt;!-- will resolve the promise returned and get set $.remote_data to the json() data of the fetch response --\u0026gt; \u0026lt;a click.handler=\u0026quot;$.remote_data = //@local/get-promise-data()\u0026quot;\u0026gt;Get Promise Data\u0026lt;/a\u0026gt; "},{"id":7,"href":"/categories/","title":"Categories","parent":"Hibiki HTML","content":""},{"id":8,"href":"/","title":"Hibiki HTML","parent":"","content":"Hibiki HTML is a powerful new web framework for creating modern, dynamic, frontend applications without JavaScript, that can be fully scripted and controlled by backend code.\nHibiki HTML is compatible with any backend language or framework, any CSS framework, and any existing backend template language.\nFor an interactive walkthrough please check out the Hibiki HTML Interactive Tutorial.\nHibiki HTML Resources     Source Code on GitHub - https://github.com/dashborg/hibiki Tutorial - https://playground.hibikihtml.com/tutorial/ Playground - https://playground.hibikihtml.com Codepen Template - https://codepen.io/pen/?template=QWMBgPg Issue Tracker https://github.com/dashborg/hibiki/issues Homepage - https://hibikihtml.com Reference Documentation - https://docs.hibikihtml.com Join Discord for Questions - https://discord.gg/zbWV6ueED7  Getting Started    Getting started is easy. There is no JavaScript stack to set up, no boilerplate/scaffolding, and no build tools to download and run. Just add one script tag to the top of your page or template:\n\u0026lt;script src=\u0026quot;https://cdn.hibikihtml.com/hibiki/latest/hibiki-prod.min.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; Wrap any portion of your content with a \u0026lt;template hibiki\u0026gt; tag and you have your first Hibiki HTML app. All plain HTML content is rendered as is, and because Hibiki HTML uses the browser\u0026rsquo;s HTML parser, it follows the same rules as standard browser HTML.\nNote that all these code examples can be viewed and edited in the Hibiki HTML Playground.\n\u0026lt;template hibiki\u0026gt; \u0026lt;h1 class=\u0026quot;title\u0026quot;\u0026gt;\u0026amp;#x1f338; Hibiki HTML\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;Hibiki HTML \u0026lt;i\u0026gt;is\u0026lt;/i\u0026gt; HTML\u0026lt;/p\u0026gt; \u0026lt;/template\u0026gt; (Playground Link - https://playground.hibikihtml.com/?codeid=readme-gs)\nData / Rendering Dynamic Content    Hibiki HTML applications have a built-in frontend data model. You can initialize it with any JSON object using the \u0026lt;hibiki-data\u0026gt; tag. To render text use the \u0026lt;h-text\u0026gt; tag or inline {{ ... }} syntax. Attributes and style properties are evaluated dynamically if they start with a *.\n\u0026lt;template hibiki\u0026gt; \u0026lt;hibiki-data\u0026gt; {\u0026quot;color\u0026quot;: \u0026quot;blue\u0026quot;, \u0026quot;name\u0026quot;: \u0026quot;Mike\u0026quot;} \u0026lt;/hibiki-data\u0026gt; \u0026lt;p\u0026gt; {{ $.name }}'s favorite color is \u0026lt;span style=\u0026quot;font-weight: bold; color: *$.color\u0026quot;\u0026gt;{{ $.color }}\u0026lt;/span\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;/template\u0026gt; (Playground Link - https://playground.hibikihtml.com/?codeid=readme-data-1)\nHibiki HTML supports a full expression language, including all of the standard conditional and arithmetic operators. Additional classes can be turned on/off using the shorthand attribute syntax class.[class-name]=\u0026quot;true/false expression\u0026quot;.\n\u0026lt;template hibiki\u0026gt; \u0026lt;hibiki-data\u0026gt; {\u0026quot;numlights\u0026quot;: 4, \u0026quot;selected\u0026quot;: true, \u0026quot;index\u0026quot;: 5, \u0026quot;isprimary\u0026quot;: true} \u0026lt;/hibiki-data\u0026gt; \u0026lt;div class=\u0026quot;box\u0026quot; style=\u0026quot;font-weight: *($.selected ? 'bold' : 'normal')\u0026quot;\u0026gt; Bold Text (if selected) \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026quot;box\u0026quot;\u0026gt;Index: \u0026lt;h-text bind=\u0026quot;$.index + 1\u0026quot;\u0026gt;\u0026lt;/h-text\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026quot;box\u0026quot;\u0026gt; There are {{$.numlights}} light{{$.numlights \u0026gt; 1 ? 's' : ''}} \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026quot;box\u0026quot;\u0026gt; \u0026lt;button class=\u0026quot;button\u0026quot; class.is-primary=\u0026quot;*$.isprimary\u0026quot;\u0026gt;Primary Button\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; (Playground Link - https://playground.hibikihtml.com/?codeid=readme-data-2)\nYou can conditionally include elements using the if attribute. Looping is handled by the foreach attribute. You can loop over arrays or objects. The foreach attribute uses a special syntax of @item in $.array, where every iteration @item will be assigned to an element of the array or object. If you provide a second variable it will capture the array index or element key: (@item, @key) in $.object or (@item, @idx) in $.array.\n\u0026lt;template hibiki\u0026gt; \u0026lt;hibiki-data\u0026gt; {\u0026quot;fruits\u0026quot;: [{\u0026quot;name\u0026quot;: \u0026quot;apple\u0026quot;, \u0026quot;emoji\u0026quot;: \u0026quot;\u0026amp;#127822;\u0026quot;}, {\u0026quot;name\u0026quot;: \u0026quot;banana\u0026quot;, \u0026quot;emoji\u0026quot;: \u0026quot;\u0026amp;#127820;\u0026quot;}, {\u0026quot;name\u0026quot;: \u0026quot;blueberry\u0026quot;, \u0026quot;emoji\u0026quot;: \u0026quot;\u0026amp;#129744;\u0026quot;}], \u0026quot;selected\u0026quot;: \u0026quot;banana\u0026quot;} \u0026lt;/hibiki-data\u0026gt; \u0026lt;div class=\u0026quot;content box\u0026quot;\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li foreach=\u0026quot;@fruit in $.fruits\u0026quot;\u0026gt; {{ @fruit.name }} {{ @fruit.emoji }} \u0026lt;span if=\u0026quot;@fruit.name == $.selected\u0026quot;\u0026gt;(selected)\u0026lt;/span\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; (Playground Link - https://playground.hibikihtml.com/?codeid=readme-data-3)\nHandlers    To update data (and dynamically change content), Hibiki HTML supports handlers. Basic handlers respond to events like click, mount, submit, change, etc.\n\u0026lt;template hibiki\u0026gt; \u0026lt;hibiki-data\u0026gt;{\u0026quot;color\u0026quot;: \u0026quot;blue\u0026quot;}\u0026lt;/hibiki-data\u0026gt; \u0026lt;div class=\u0026quot;box\u0026quot; style=\u0026quot;background-color: *$.color; color: white\u0026quot;\u0026gt; The color is {{$.color}} \u0026lt;/div\u0026gt; \u0026lt;button class=\u0026quot;button\u0026quot; click.handler=\u0026quot;$.color = 'green'\u0026quot;\u0026gt;Change Color\u0026lt;/button\u0026gt; \u0026lt;/template\u0026gt; (Playground Link - https://playground.hibikihtml.com/?codeid=readme-handlers-1)\nYou can make remote AJAX calls for JSON data using a remote handler. In this example the call to https://testapi.hibikihtml.com/api/get-color-1 will return the JSON response {\u0026quot;color\u0026quot;: \u0026quot;purple\u0026quot;}. We assign it to a context variable @resp and then assign $.color = @resp.color.\n\u0026lt;template hibiki\u0026gt; \u0026lt;hibiki-data\u0026gt;{\u0026quot;color\u0026quot;: \u0026quot;blue\u0026quot;}\u0026lt;/hibiki-data\u0026gt; \u0026lt;div class=\u0026quot;box\u0026quot; style=\u0026quot;background-color: *$.color; color: white\u0026quot;\u0026gt; The color is {{$.color}} \u0026lt;/div\u0026gt; \u0026lt;button class=\u0026quot;button\u0026quot; click.handler=\u0026quot;$.color = 'green'\u0026quot;\u0026gt;Change Color\u0026lt;/button\u0026gt; \u0026lt;button class=\u0026quot;button\u0026quot; click.handler=\u0026quot;@resp = GET https://testapi.hibikihtml.com/api/get-color-1; $.color = @resp.color;\u0026quot;\u0026gt; GET /api/get-color-1 \u0026lt;/button\u0026gt; \u0026lt;/template\u0026gt; (Playground Link - https://playground.hibikihtml.com/?codeid=readme-handlers-2)\nYou can make GET, POST, PUT, PATCH, or DELETE requests by changing the verb in front of the URL. You can pass query arguments (or JSON data bodies) by passing arguments to your handler by using (arg1=val1, arg2=val2...) (complex arguments will be JSON encoded), and you can define local handlers using the define-handler tag for convenience and reuse.\n\u0026lt;template hibiki\u0026gt; \u0026lt;hibiki-data\u0026gt;{\u0026quot;color\u0026quot;: \u0026quot;blue\u0026quot;}\u0026lt;/hibiki-data\u0026gt; \u0026lt;define-handler name=\u0026quot;//@local/get-color\u0026quot;\u0026gt; @resp = GET https://testapi.hibikihtml.com/api/get-color-1(name=\u0026quot;Michelle\u0026quot;); $.color = @resp.color; \u0026lt;/define-handler\u0026gt; \u0026lt;div class=\u0026quot;box\u0026quot; style=\u0026quot;background-color: *$.color; color: white\u0026quot;\u0026gt; The color is {{$.color}} \u0026lt;/div\u0026gt; \u0026lt;button class=\u0026quot;button\u0026quot; click.handler=\u0026quot;$.color = 'green'\u0026quot;\u0026gt;Change Color\u0026lt;/button\u0026gt; \u0026lt;button class=\u0026quot;button\u0026quot; click.handler=\u0026quot;//@local/get-color\u0026quot;\u0026gt; Get Michelle's Color \u0026lt;/button\u0026gt; \u0026lt;/template\u0026gt; (Playground Link - https://playground.hibikihtml.com/?codeid=readme-handlers-3)\nConnecting to an existing API? Don\u0026rsquo;t worry, Hibiki HTML handlers support advanced options like CORS, CSRF, parameter encodings, BLOB results, and multipart file uploads.\nHibiki Actions    The magic of Hibiki HTML is that every handler is really just a series of actions. Hibiki Actions are primitives like setdata, if, callhandler, fireevent, invalidate, html, etc. Every action that can you can write in a handler, also has a JSON representation.\nThis means we can write a backend handler that returns a JSON response that scripts and updates the frontend! Here\u0026rsquo;s an example JSON response that is equivalent to running $.color = 'DeepSkyBlue' on the frontend:\n{\u0026quot;hibikiactions\u0026quot;: [ {\u0026quot;actiontype\u0026quot;: \u0026quot;setdata\u0026quot;, \u0026quot;setpath\u0026quot;: \u0026quot;$.color\u0026quot;, \u0026quot;data\u0026quot;: \u0026quot;DeepSkyBlue\u0026quot;} ]} I\u0026rsquo;ve set up https://testapi.hibikihtml.com/api/set-color-action to return just that. Now if we have our click handler call that URL, we\u0026rsquo;ll see the color change automatically.\n\u0026lt;template hibiki\u0026gt; \u0026lt;hibiki-data\u0026gt;{\u0026quot;color\u0026quot;: \u0026quot;red\u0026quot;}\u0026lt;/hibiki-data\u0026gt; \u0026lt;div class=\u0026quot;box\u0026quot; style=\u0026quot;background-color: *$.color; color: white\u0026quot;\u0026gt; The color is {{$.color}} \u0026lt;/div\u0026gt; \u0026lt;button class=\u0026quot;button\u0026quot; click.handler=\u0026quot;$.color = 'green'\u0026quot;\u0026gt;Change Color\u0026lt;/button\u0026gt; \u0026lt;button class=\u0026quot;button\u0026quot; click.handler=\u0026quot;GET https://testapi.hibikihtml.com/api/set-color-action;\u0026quot;\u0026gt; Backend Set Color Action \u0026lt;/button\u0026gt; \u0026lt;/template\u0026gt; (Playground Link - https://playground.hibikihtml.com/?codeid=readme-actions-1)\nBackend handlers are very powerful. You can set return values, return data and BLOBs (like images) in one request, mix frontend and backend data with expressions, conditionally execute actions, and more. You can also use backend handlers to create multi-page Hibiki HTML applications by returning a new HTML template to be rendered.\nComponents and Libraries    Hibiki HTML makes it easy to use, share, and bundle components for easy reuse. The ecosystem is just getting started, but you can write native Hibiki HTML components, link to 3rd party JavaScript (D3, CodeMirror, etc.), and import ReactJS components.\n\u0026lt;template hibiki\u0026gt; \u0026lt;define-component name=\u0026quot;colorbox\u0026quot;\u0026gt; \u0026lt;div class=\u0026quot;box\u0026quot; style=\u0026quot;background-color: *$args.color; color: white\u0026quot;\u0026gt; The color is {{$args.color}} \u0026lt;/div\u0026gt; \u0026lt;/define-component\u0026gt; \u0026lt;local-colorbox color=\u0026quot;green\u0026quot;\u0026gt;\u0026lt;/local-colorbox\u0026gt; \u0026lt;local-colorbox color=\u0026quot;blue\u0026quot;\u0026gt;\u0026lt;/local-colorbox\u0026gt; \u0026lt;local-colorbox color=\u0026quot;purple\u0026quot;\u0026gt;\u0026lt;/local-colorbox\u0026gt; \u0026lt;/template\u0026gt; (Playground Link - https://playground.hibikihtml.com/?codeid=readme-comps-1)\nInteractive Tutorial    Want to learn more? Check out the Interactive Tutorial.\n Open Source    The source code for Hibiki HTML is available on GitHub at at: https://github.com/dashborg/hibiki . It is licensed under the Mozilla Public License v2.0 \u0026ndash; https://mozilla.org/MPL/2.0/ .\nMozilla has an excellent FAQ, but basically this license allows you to use Hibiki HTML in any project (personal, commercial, or open-source). The only restriction is if you modify any of the Hibiki HTML source files you must make the source code of those changes available.\nCredits    Hibiki HTML is an open source version of the frontend language originally built and designed for the Dashborg internal tools framework. The Hibiki HTML core is built in TypeScript, using React, MobX, and Nearley. The Hibiki HTML playground is built in Hibiki HTML, also using CodeMirror and Bulma.\nSupport and Help    Hibiki HTML is under active development. Please contact me by email [mike (at) hibikihtml.com] or on Discord if you have a question, to report a bug, need help, or would like to contribute.\nI\u0026rsquo;m excited to see Hibiki HTML working in the real world. If you have an application that you\u0026rsquo;re thinking about using Hibiki HTML for, please reach out. I\u0026rsquo;m happy to help, build out additional functionality/components, or do team training.\nJoin the Hibiki HTML Discord Server\n"},{"id":9,"href":"/reference/http-module/","title":"Http Module","parent":"Reference","content":"    Parameters to Handler Calls Dynamic URLs Http Config Additional HTTP Modules     The http module is used for all basic AJAX calls in Hibiki HTML. It allows you to call AJAX handlers and returns their results.\nThe module is named http, but it handles both http and https requests!  Here are some sample http module calls:\n # simple GET GET /api/test-1 # a relative URL GET relative/url.html?test=1 # POST to a remote resource POST https://remoteserver.any.com/api/test-post # 'GET' can be omitted for URLs that start with http, https, or // https://testapi.hibikihtml.com/api/random-number # adding a parameter x=55, will be added to URL # e.g. equivalent to /api/test-1?y=22\u0026amp;x=55 GET /api/test-1?y=22(x=55) # POST, with url encoded parameters POST /api/test-post(user={id: 55, name: 'mike'}, access_code='A55', @enc='url') Each call can be configured by passing special @ parameters. Global configuration is done through the httpConfig key of the global \u0026lt;hibiki-config\u0026gt;.\nSometimes you need special http options for a particular host (e.g. a REST endpoint that requires special headers or CSRF handling). You can set that up easily by adding an addition HTTP module (see Additional HTTP Modules below).\nParameters to Handler Calls    Any non @ parameter is considered data and will be passed to the AJAX handler. Here are the special parameters that all http calls accept. See the fetch() API documentation.\n   Parameter Type Description     @method string Overrides the http method for this request. e.g. @method=\u0026lsquo;POST\u0026rsquo;   @encoding string Sets the encoding for this request. Defaults to \u0026lsquo;json\u0026rsquo;. Other valid values are \u0026lsquo;url\u0026rsquo; for application/x-www-form-urlencoded, or \u0026lsquo;multipart\u0026rsquo; for multipart/form-data.   @data object To pass data an an object. e.g. @data={x: 55, color: \u0026ldquo;blue\u0026rdquo;}. Individual params set will override what is specified in data. e.g. (@data={x: 55, y:5}, x=22) will set x to 22 and y to 5.   @csrf string Set the CSRF token for this request. Overrides the value that would have been produced by the default config (csrfToken). Note that the rest of the CSRF checks will still apply (csrfAllowedOrigins and csrfMethods) so specifiying @csrf does not guarantee a CSRF token will be sent.   @headers object An object with header names as keys, and values as header values. Used to set additional headers on the request. e.g. @headers={\u0026ldquo;X-User-Id\u0026rdquo;: $.userid}.   @mode string Overrides the fetch \u0026lsquo;mode\u0026rsquo;. \u0026lsquo;cors\u0026rsquo;, \u0026lsquo;no-cors\u0026rsquo;, or \u0026lsquo;same-origin\u0026rsquo;   @credentials string Overrides the fetch \u0026lsquo;credentials\u0026rsquo;. \u0026lsquo;omit\u0026rsquo;, \u0026lsquo;same-origin\u0026rsquo;, or \u0026lsquo;include\u0026rsquo;.   @init string Sets the default fetchInit object. This is the base object that will be used, and then additional \u0026lsquo;@\u0026rsquo; params and configuration defaults will be applied. This can be used to set uncommon values that are not covered by the other \u0026lsquo;@\u0026rsquo; params, e.g. \u0026lsquo;cache\u0026rsquo;, \u0026lsquo;redirect\u0026rsquo;, \u0026lsquo;referrer\u0026rsquo;, \u0026lsquo;referrerPolicy\u0026rsquo;, \u0026lsquo;integrity\u0026rsquo;, \u0026lsquo;keepalive\u0026rsquo;, etc.    These \u0026lsquo;@\u0026rsquo; params are used for one-off overrides of individual requests. If you always want to send a particular header or set a special init setting, it can often be easier to specify the value in the HttpConfig object (see below).\nDynamic URLs    To make an AJAX handler call with a dynamic URL, you need to use the callhandler statement. It takes the same parameters (above), but additionally it takes two more @url and @module:\n   Paramter Type Description     @url string the URL to fetch (passed to the module), required   @module string the module to use, defaults to the \u0026lsquo;http\u0026rsquo; module (which also handles \u0026lsquo;https\u0026rsquo; calls)    Here\u0026rsquo;s some examples:\ncallhandler(@url=\u0026quot;https://testapi.hibikihtml.com/api/get-color-1\u0026quot;); @handler_name = 'get-color-' + $.colornum; callhandler(@url=\u0026quot;https://testapi.hibikihtml.com/api/\u0026quot; + @handler_name) # hibiki module call, equivalent to //@hibiki/sleep(ms=1000); callhandler(@module=\u0026quot;hibiki\u0026quot;, @url=\u0026quot;/sleep\u0026quot;, ms=1000); Http Config    Http Config is set as the httpConfig key of the global \u0026lt;hibiki-config\u0026gt;:\n\u0026lt;template hibiki\u0026gt; \u0026lt;hibiki-config\u0026gt; { ... other config options ... \u0026quot;httpConfig\u0026quot;: { ... http options ... } } \u0026lt;/hibiki-config\u0026gt; \u0026lt;/template\u0026gt;    Key Type Description     baseUrl string Relative URLs will be made relative against the specified URL. If not specified, relative URLs will be built against window.location.href.   lockToBaseOrigin boolean If set to true, will throw an error if trying to fetch an URL that has a different origin from the specified baseUrl (or window.location.href if baseUrl is not set).   forceRelativeUrls boolean If set to true, will throw an error if trying to fetch an URL which is not relative to the baseUrl. e.g. if baseUrl is \u0026lsquo;https://hibikihtml.com/test/', an url with a different host name, protocol, port, or that does not begin with \u0026lsquo;/test/\u0026rsquo; would be rejected.   defaultHeaders headerName -\u0026gt; actionStr Custom headers to be added to every request. See below for more details.   defaultInit object Default init object to be passed to fetch. see fetch API   csrfToken string or actionString CSRF token for requests. Can be specified as a literal string, or as a hibiki action string (to dynamically pull it from the data model)   csrfMethods string[] an array of HTTP methods to pass the CSRF token to.\ndefaults to [\u0026ldquo;POST\u0026rdquo;, \u0026ldquo;PUT\u0026rdquo;, \u0026ldquo;PATCH\u0026rdquo;]   csrfParams string[] if a CSRF token is found, an array of parameter names to set with the token\u0026rsquo;s value. Defaults to []. e.g. can set to [\u0026quot;_token\u0026quot;] for a framework like Laravel.   csrfHeaders string[] if a CSRF token is found, an array of header names to set with the token\u0026rsquo;s value. Defaults to [\u0026ldquo;X-CSRF-Token\u0026rdquo;, \u0026ldquo;X-CSRFToken\u0026rdquo;]. This is the default for many backend libraries.   csrfAllowedOrigins string[] Restricts the CSRF token from being sent to only the listed origins. Defaults to the baseUrl\u0026rsquo;s origin. Can set to [\u0026quot;*\u0026quot;] to send to all origins.   fetchHookFn hookFn A hook function that runs right before fetch() is called. ((url : URL, fetchInit : any) =\u0026gt; void). Can modify url or fetchInit. To cancel the request it can throw an exception.    Additional HTTP Modules    If you are making requests to multiple endpoints which require different headers, CSRF settings, or fetchInit parameters, you can configure additional HTTP modules.\nHere\u0026rsquo;s an example config that sets up a module named \u0026lsquo;app\u0026rsquo; that always includes an \u0026lsquo;X-UserId\u0026rsquo; header set to a hibikiexpr of \u0026lsquo;$.userid\u0026rsquo;, a static header (X-Domain-Id), and a special CSRF configuration. Notes:\n The name of the module is the key under \u0026ldquo;modules\u0026rdquo;, in this case \u0026ldquo;app\u0026rdquo;. The \u0026ldquo;type\u0026rdquo; key is required. For HTTP modules it must be set to \u0026ldquo;http\u0026rdquo;. The rest of the configuration matches the HttpConfig section above. For special modules that are for specific API endpoints, you should set \u0026ldquo;forceRelativeUrls\u0026rdquo; to only allow allow this configuration for requests to the specific origin / subpath.  \u0026lt;hibiki-config\u0026gt; { \u0026quot;modules\u0026quot;: { \u0026quot;app\u0026quot;: {\u0026quot;type\u0026quot;: \u0026quot;http\u0026quot;, \u0026quot;baseUrl\u0026quot;: \u0026quot;https://my.api.com/api/v2/\u0026quot;, \u0026quot;forceRelativeUrls\u0026quot;: true, \u0026quot;defaultHeaders\u0026quot;: { \u0026quot;X-UserId\u0026quot;: {\u0026quot;hibikiexpr\u0026quot;: \u0026quot;$.userid\u0026quot;}, \u0026quot;X-Domain-Id\u0026quot;: \u0026quot;81288642\u0026quot; }, \u0026quot;csrfToken\u0026quot;: {\u0026quot;hibikiexpr\u0026quot;: \u0026quot;$.apitoken\u0026quot;}, \u0026quot;csrfParams\u0026quot;: [\u0026quot;_token\u0026quot;] } } } \u0026lt;/hibiki-config\u0026gt; You can now use the \u0026lsquo;app\u0026rsquo; module to make requests to \u0026ldquo;my.api.com\u0026rdquo; with the given HTTP settings:\n# makes a GET request to https://my.api.com/api/v2/get-data GET //@app/get-data(id=22); # makes a POST request to https://my.api.com/api/v2/primary-name/set-name POST //@app/primary-name/set-name(name='mike'); "},{"id":10,"href":"/reference/input-controls/","title":"Input Controls","parent":"Reference","content":"    Standard Managed Elements \u0026lt;input type=\u0026ldquo;radio\u0026rdquo;\u0026gt; \u0026lt;input type=\u0026ldquo;checkbox\u0026rdquo;\u0026gt; \u0026lt;input type=\u0026ldquo;file\u0026rdquo;\u0026gt; \u0026lt;input type=\u0026ldquo;hidden\u0026rdquo;\u0026gt; \u0026lt;form\u0026gt; Other \u0026lt;input\u0026gt; Types     Standard Managed Elements     \u0026lt;input type=\u0026ldquo;text\u0026rdquo;\u0026gt; \u0026lt;input type=\u0026ldquo;password\u0026rdquo;\u0026gt; \u0026lt;textarea\u0026gt; \u0026lt;select\u0026gt; HTML5 \u0026lt;input\u0026gt; types: color, date, datetime-local, email, month, number, search, tel, time, url, week, and datetime  For 2-way data-binding, set value.bindpath. The element\u0026rsquo;s value will be read from the provided path, and on change the bindpath will be updated. A change event will fire before the bindpath is updated with @value set to the new value.\nFor 1-way data-binding, add the bound attribute and set value appropriately. The element\u0026rsquo;s value will be read from the provided path. A change event will fire with @value set to the new value, it is up to your code to update the value if appropriate.\nIf neither value.bindpath nor bound is set, the component will not be managed by Hibiki HTML.\nNote that for \u0026lt;select\u0026gt; if the multiple attribute is set, the bindpath and event @value will be an array. When using a managed \u0026lt;select\u0026gt; the selected attribute on individual \u0026lt;option\u0026gt; tags is ignored.\n\u0026lt;input type=\u0026ldquo;radio\u0026rdquo;\u0026gt;    For 2-way data-binding set formvalue.bindpath (do not set the checked attribute). When this radio button is selected, the bindpath will be set to this radio button\u0026rsquo;s value. The checked attribute will be set automatically whenever the bindpath matches this radio button\u0026rsquo;s value. A change event will fire whenever this radio button is selected (before the the bindpath is updated) with @value always set to true. Radio groups can be managed by setting each button\u0026rsquo;s formvalue.bindpath to the same value.\nFor 1-way data-binding add the bound attribute and set value and checked appropriately. Radio inputs cannot be deselected by the user, so the change event only fires when a radio button becomes selected (@value will always be true). Your code must manage the checked attributes appropriately for other radio controls in the same group.\nIf neither formvalue.bindpath nor bound is set, the component will not be managed by Hibiki HTML.\n\u0026lt;input type=\u0026ldquo;checkbox\u0026rdquo;\u0026gt;    For simple boolean 2-way control set checked.bindpath. The element\u0026rsquo;s checked state will be read from the bindpath as a boolean, and when it is checked or unchecked the bindpath will be updated to true or false as appropriate. A change event will fire before the bindpath is updated with @value set to the new checkbox\u0026rsquo;s state (before bindpath is updated).\nTo manage checkbox groups with 2-way control, set formdata.bindpath (do not set the checked attribute). The bindpath will be set to an array (set) taken from the checkbox\u0026rsquo;s value attribute. When a checkbox is checked, its value will be added to the set. If a checkbox is unchecked its value will be removed from the set. Checkbox groups can be managed by setting each checkbox\u0026rsquo;s formvalue.bindpath to the same value. A change event will be fired whenever the checkbox is checked or unchecked with @value set to true or false as appropriate.\nTo manage a checkbox with 1-way control, add the bound attribute and set checked appropriately. A change event will fire when the user checks or unchecks the control with @value set to true or false as appropriate. Your code must manage the checked attribute appropriately.\nIf neither checked.bindpath, formvalue.bindpath nor bound is set, the component will not be managed by Hibiki HTML.\nIf both checked.bindpath and formdata.bindpath are set, formdata.bindpath will be ignored.\n\u0026lt;input type=\u0026ldquo;file\u0026rdquo;\u0026gt;    HTML file inputs do not allow their value to be set. If value.bindpath is set, on change, a HibikiBlob will be written to the specified path. If no file(s) are selected the bindpath will be set to null. A change event will fire before the bindpath is updated with @value set to the new value.\nNote that if the multiple attribute is set, the bindpath and event @value will be an array of HibikiBlobs.\n\u0026lt;input type=\u0026ldquo;hidden\u0026rdquo;\u0026gt;    As a convenience, hidden inputs can set (output only) their value into the data-model using formvalue.bindpath. If their value is dynamic, the bindpath will be set each time the value changes.\n\u0026lt;form\u0026gt;    If you do not provide a submit.handler for your form element it will not be managed by Hibiki HTML (will submit with its action attribute as normal).\nIf you do set submit.handler the form will not submit like a normal HTML form, it will instead run the submit handler. The submit handler will receive @formdata which is set with the values of all of the input controls associated with the form (including file inputs which will set HibikiBlob objects). @formdata can be passed directly to call handlers as @data to pass all the data elements to the handler: GET /api/handler(@data=@formdata).\nOther \u0026lt;input\u0026gt; Types    Other input types including: submit, button, image, and reset are not managed. Their attributes work normally. They do not fire change events (but will fire click events).\n"},{"id":11,"href":"/reference/","title":"Reference","parent":"Hibiki HTML","content":"Welcome to the Hibiki HTML Reference documentation site. Please select a reference page in the navigation menu.\n Documentation Home Github Repository Playground Interactive Tutorial  "},{"id":12,"href":"/tags/","title":"Tags","parent":"Hibiki HTML","content":""}]